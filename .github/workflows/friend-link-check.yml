name: å‹é“¾PRæ£€æŸ¥

on:
  pull_request:
    types: [opened, synchronize, reopened]
  issue_comment:
    types: [created]

jobs:
  check-friend-link-pr:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write
      issues: write
    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Check if data.ts is modified
        id: check-files
        run: |
          git fetch origin ${{ github.event.pull_request.base.ref }}
          git diff --name-only origin/${{ github.event.pull_request.base.ref }} HEAD > changed_files.txt
          if grep -q ".vitepress/theme/untils/data.ts" changed_files.txt; then
            echo "data_ts_modified=true" >> $GITHUB_OUTPUT
          else
            echo "data_ts_modified=false" >> $GITHUB_OUTPUT
          fi

      - name: Add å‹é“¾ label
        if: steps.check-files.outputs.data_ts_modified == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['å‹é“¾']
            });

      - name: Parse data.ts and check links
        if: steps.check-files.outputs.data_ts_modified == 'true'
        id: parse-data
        run: |
          node << 'EOF'
          const fs = require('fs');
          const https = require('https');
          const http = require('http');

          // è¯»å–data.tså†…å®¹
          const content = fs.readFileSync('.vitepress/theme/untils/data.ts', 'utf8');

          // è§£æå‹æƒ…é“¾æ¥éƒ¨åˆ†
          function parseFriendLinks(content) {
            // æ‰¾åˆ°å‹æƒ…é“¾æ¥section
            const friendLinkIndex = content.search(/title:\s*['"]å‹æƒ…é“¾æ¥['"]/);
            if (friendLinkIndex === -1) {
              console.log('æœªæ‰¾åˆ°å‹æƒ…é“¾æ¥section');
              return null;
            }

            const sectionStart = content.substring(friendLinkIndex);
            const itemsIndex = sectionStart.indexOf('items:');
            if (itemsIndex === -1) {
              console.log('æœªæ‰¾åˆ°items');
              return null;
            }

            const afterItems = sectionStart.substring(itemsIndex + 6);
            let bracketIndex = afterItems.indexOf('[');
            if (bracketIndex === -1) {
              console.log('æœªæ‰¾åˆ°[');
              return null;
            }

            // æ‰¾åˆ°åŒ¹é…çš„ ]
            let depth = 0;
            let inString = false;
            let stringChar = '';
            let startIdx = bracketIndex + 1;
            let endIdx = -1;

            for (let i = startIdx; i < afterItems.length; i++) {
              const char = afterItems[i];
              const prevChar = i > 0 ? afterItems[i - 1] : '';

              if ((char === '"' || char === "'") && prevChar !== '\\') {
                if (!inString) {
                  inString = true;
                  stringChar = char;
                } else if (char === stringChar) {
                  inString = false;
                }
              }

              if (!inString) {
                if (char === '[') depth++;
                if (char === ']') {
                  if (depth === 0) {
                    endIdx = i;
                    break;
                  }
                  depth--;
                }
              }
            }

            if (endIdx === -1) {
              console.log('æœªæ‰¾åˆ°åŒ¹é…çš„]');
              return null;
            }

            const itemsContent = afterItems.substring(startIdx, endIdx);
            
            // åŒ¹é…æ¯ä¸ªå‹é“¾å¯¹è±¡ï¼ˆæ”¯æŒåµŒå¥—çš„å¤§æ‹¬å·ï¼‰
            const items = [];
            let currentItem = '';
            inString = false;
            stringChar = '';
            let itemDepth = 0;
            
            for (let i = 0; i < itemsContent.length; i++) {
              const char = itemsContent[i];
              const prevChar = i > 0 ? itemsContent[i - 1] : '';
              
              if ((char === '"' || char === "'") && prevChar !== '\\') {
                if (!inString) {
                  inString = true;
                  stringChar = char;
                } else if (char === stringChar) {
                  inString = false;
                }
              }
              
              if (!inString) {
                if (char === '{') itemDepth++;
                if (char === '}') itemDepth--;
              }
              
              // åªæœ‰åœ¨å¯¹è±¡å†…éƒ¨æ—¶æ‰æ·»åŠ åˆ°å½“å‰é¡¹
              if (itemDepth > 0 || (itemDepth === 0 && char === '}')) {
                currentItem += char;
              }
              
              // ä¸€ä¸ªå®Œæ•´çš„å¯¹è±¡
              if (itemDepth === 0 && currentItem.trim().startsWith('{') && char === '}') {
                items.push(currentItem.trim());
                currentItem = '';
              }
            }

            // è§£ææ¯ä¸ªitem
            return items.map(item => {
              const result = {};
              
              // æå–icon
              const iconMatch = item.match(/icon:\s*['"]([^'"]*)['"]/);
              result.icon = iconMatch ? iconMatch[1] : '';
              
              // æå–title
              const titleMatch = item.match(/title:\s*['"]([^'"]+)['"]/);
              result.title = titleMatch ? titleMatch[1] : '';
              
              // æå–link
              const linkMatch = item.match(/link:\s*['"]([^'"]+)['"]/);
              result.link = linkMatch ? linkMatch[1] : '';
              
              // æå–descï¼ˆå¯é€‰ï¼‰
              const descMatch = item.match(/desc:\s*['"]([^'"]*)['"]/);
              result.desc = descMatch ? descMatch[1] : '';
              
              // æå–badgeï¼ˆå¯é€‰ï¼‰
              const badgeMatch = item.match(/badge:\s*\{[\s\S]*?\}/);
              if (badgeMatch) {
                const textMatch = badgeMatch[0].match(/text:\s*['"]([^'"]+)['"]/);
                const typeMatch = badgeMatch[0].match(/type:\s*['"]([^'"]+)['"]/);
                result.badge = {
                  text: textMatch ? textMatch[1] : '',
                  type: typeMatch ? typeMatch[1] : ''
                };
              }
              
              return result;
            }).filter(item => item.title && item.link);
          }

          const friendLinks = parseFriendLinks(content);

          if (!friendLinks || friendLinks.length === 0) {
            console.log('æœªæ‰¾åˆ°å‹é“¾æ•°æ®');
            process.exit(1);
          }

          // æ‰¾åˆ°æœ€åä¸€ä¸ªå‹é“¾ï¼ˆå‡è®¾æ˜¯æ–°å¢çš„ï¼‰
          const lastItem = friendLinks[friendLinks.length - 1];
          console.log('Found friend link:', JSON.stringify(lastItem, null, 2));

          // è®¾ç½®è¾“å‡º
          const fs2 = require('fs');
          fs2.appendFileSync(process.env.GITHUB_OUTPUT, `title=${lastItem.title}\n`);
          fs2.appendFileSync(process.env.GITHUB_OUTPUT, `icon=${lastItem.icon}\n`);
          fs2.appendFileSync(process.env.GITHUB_OUTPUT, `link=${lastItem.link}\n`);
          fs2.appendFileSync(process.env.GITHUB_OUTPUT, `desc=${lastItem.desc || ''}\n`);

          // æ£€æŸ¥é“¾æ¥å¯è¾¾æ€§
          async function checkUrl(url, isImage = false) {
            return new Promise((resolve) => {
              if (!url || url === '') {
                resolve({ reachable: false, status: 'æ— URL' });
                return;
              }
              
              const client = url.startsWith('https') ? https : http;
              const options = { 
                timeout: 10000,
                method: 'HEAD'  // ä½¿ç”¨HEADè¯·æ±‚æ›´å¿«
              };
              
              const req = client.request(url, options, (res) => {
                // å¤„ç†é‡å®šå‘
                if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
                  checkUrl(res.headers.location, isImage).then(resolve);
                  return;
                }
                resolve({ reachable: res.statusCode < 400, status: res.statusCode });
              });
              
              req.on('error', () => {
                // HEADå¤±è´¥æ—¶å°è¯•GET
                if (!isImage) {
                  const getReq = client.get(url, { timeout: 10000 }, (res) => {
                    resolve({ reachable: res.statusCode < 400, status: res.statusCode });
                  });
                  getReq.on('error', () => resolve({ reachable: false, status: 'Error' }));
                  getReq.on('timeout', () => {
                    getReq.destroy();
                    resolve({ reachable: false, status: 'Timeout' });
                  });
                } else {
                  resolve({ reachable: false, status: 'Error' });
                }
              });
              
              req.on('timeout', () => {
                req.destroy();
                resolve({ reachable: false, status: 'Timeout' });
              });
              
              req.end();
            });
          }

          async function runChecks() {
            // iconä¸ºç©ºæ—¶ä¸æ£€æŸ¥
            const iconResult = lastItem.icon ? await checkUrl(lastItem.icon, true) : { reachable: true, status: 'æ— å›¾æ ‡' };
            const linkResult = await checkUrl(lastItem.link, false);

            console.log('Icon check:', iconResult);
            console.log('Link check:', linkResult);

            fs2.appendFileSync(process.env.GITHUB_OUTPUT, `icon_reachable=${iconResult.reachable}\n`);
            fs2.appendFileSync(process.env.GITHUB_OUTPUT, `link_reachable=${linkResult.reachable}\n`);
            fs2.appendFileSync(process.env.GITHUB_OUTPUT, `all_reachable=${iconResult.reachable && linkResult.reachable}\n`);
          }

          runChecks().then(() => process.exit(0));
          EOF

      - name: Update PR title
        if: steps.check-files.outputs.data_ts_modified == 'true' && steps.parse-data.outputs.title != ''
        uses: actions/github-script@v7
        with:
          script: |
            const title = '${{ steps.parse-data.outputs.title }}';
            if (title && title !== 'è™šä½ä»¥å¾…') {
              github.rest.pulls.update({
                pull_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title
              });
            }

      - name: Add reachability labels
        if: steps.check-files.outputs.data_ts_modified == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const labels = [];
            const iconReachable = '${{ steps.parse-data.outputs.icon_reachable }}' === 'true';
            const linkReachable = '${{ steps.parse-data.outputs.link_reachable }}' === 'true';
            const allReachable = '${{ steps.parse-data.outputs.all_reachable }}' === 'true';

            if (iconReachable) {
              labels.push('å¤´åƒå¯è¾¾');
            } else {
              labels.push('å¤´åƒä¸å¯è¾¾');
            }

            if (linkReachable) {
              labels.push('ç½‘ç«™å¯è¾¾');
            } else {
              labels.push('ç½‘ç«™ä¸å¯è¾¾');
            }

            if (allReachable) {
              labels.push('æ‰€æœ‰æƒéªŒè¯è¿›è¡Œä¸­');
            }

            github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: labels
            });

      - name: Comment for ownership verification
        if: steps.check-files.outputs.data_ts_modified == 'true' && steps.parse-data.outputs.all_reachable == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const link = '${{ steps.parse-data.outputs.link }}';
            const prNumber = context.issue.number;
            
            // ç”ŸæˆéªŒè¯æ–‡ä»¶å
            const urlObj = new URL(link);
            const verifyFileName = `github-pr-verify-${prNumber}.txt`;
            
            const body = `## ğŸ” å‹é“¾æ£€æŸ¥å®Œæˆ

æ‰€æœ‰é“¾æ¥æ£€æŸ¥é€šè¿‡ï¼

### æ‰€æœ‰æƒéªŒè¯

è¯·åœ¨æ‚¨çš„ç½‘ç«™æ ¹ç›®å½•æ”¾ç½®ä¸€ä¸ªåä¸º \`${verifyFileName}\` çš„æ–‡æœ¬æ–‡ä»¶ï¼Œæ–‡ä»¶å†…å®¹ä¸ºï¼š

\`\`\`
verify-pr-${prNumber}
\`\`\`

æ”¾ç½®å®Œæˆåï¼Œè¯·åœ¨æ­¤PRä¸‹å›å¤ **"å‡†å¤‡å®Œæ¯•"** ä»¥è¿›è¡ŒéªŒè¯ã€‚

éªŒè¯URL: \`${link}/${verifyFileName}\``;

            github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  verify-and-merge:
    if: github.event_name == 'issue_comment' && contains(github.event.comment.body, 'å‡†å¤‡å®Œæ¯•')
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write
      issues: write
    steps:
      - name: Get PR info
        id: pr-info
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              pull_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            const hasFriendLinkLabel = pr.data.labels.some(l => l.name === 'å‹é“¾');
            const hasVerifyLabel = pr.data.labels.some(l => l.name === 'æ‰€æœ‰æƒéªŒè¯è¿›è¡Œä¸­');
            
            core.setOutput('has_friend_link_label', hasFriendLinkLabel);
            core.setOutput('has_verify_label', hasVerifyLabel);
            core.setOutput('head_sha', pr.data.head.sha);
            core.setOutput('pr_number', context.issue.number);

      - name: Checkout PR
        if: steps.pr-info.outputs.has_friend_link_label == 'true' && steps.pr-info.outputs.has_verify_label == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ steps.pr-info.outputs.head_sha }}

      - name: Parse data.ts and verify ownership
        if: steps.pr-info.outputs.has_friend_link_label == 'true' && steps.pr-info.outputs.has_verify_label == 'true'
        id: verify
        run: |
          node << 'EOF'
          const fs = require('fs');
          const https = require('https');
          const http = require('http');

          const prNumber = '${{ steps.pr-info.outputs.pr_number }}';

          // è¯»å–data.tså†…å®¹
          const content = fs.readFileSync('.vitepress/theme/untils/data.ts', 'utf8');

          // è§£æå‹æƒ…é“¾æ¥éƒ¨åˆ†ï¼ˆä¸ä¸Šé¢ç›¸åŒçš„è§£æé€»è¾‘ï¼‰
          function parseFriendLinks(content) {
            const friendLinkIndex = content.search(/title:\s*['"]å‹æƒ…é“¾æ¥['"]/);
            if (friendLinkIndex === -1) return null;

            const sectionStart = content.substring(friendLinkIndex);
            const itemsIndex = sectionStart.indexOf('items:');
            if (itemsIndex === -1) return null;

            const afterItems = sectionStart.substring(itemsIndex + 6);
            let bracketIndex = afterItems.indexOf('[');
            if (bracketIndex === -1) return null;

            let depth = 0;
            let inString = false;
            let stringChar = '';
            let startIdx = bracketIndex + 1;
            let endIdx = -1;

            for (let i = startIdx; i < afterItems.length; i++) {
              const char = afterItems[i];
              const prevChar = i > 0 ? afterItems[i - 1] : '';

              if ((char === '"' || char === "'") && prevChar !== '\\') {
                if (!inString) {
                  inString = true;
                  stringChar = char;
                } else if (char === stringChar) {
                  inString = false;
                }
              }

              if (!inString) {
                if (char === '[') depth++;
                if (char === ']') {
                  if (depth === 0) {
                    endIdx = i;
                    break;
                  }
                  depth--;
                }
              }
            }

            if (endIdx === -1) return null;

            const itemsContent = afterItems.substring(startIdx, endIdx);
            const items = [];
            let currentItem = '';
            inString = false;
            stringChar = '';
            let itemDepth = 0;
            
            for (let i = 0; i < itemsContent.length; i++) {
              const char = itemsContent[i];
              const prevChar = i > 0 ? itemsContent[i - 1] : '';
              
              if ((char === '"' || char === "'") && prevChar !== '\\') {
                if (!inString) {
                  inString = true;
                  stringChar = char;
                } else if (char === stringChar) {
                  inString = false;
                }
              }
              
              if (!inString) {
                if (char === '{') itemDepth++;
                if (char === '}') itemDepth--;
              }
              
              if (itemDepth > 0 || (itemDepth === 0 && char === '}')) {
                currentItem += char;
              }
              
              if (itemDepth === 0 && currentItem.trim().startsWith('{') && char === '}') {
                items.push(currentItem.trim());
                currentItem = '';
              }
            }

            return items.map(item => {
              const result = {};
              const iconMatch = item.match(/icon:\s*['"]([^'"]*)['"]/);
              result.icon = iconMatch ? iconMatch[1] : '';
              const titleMatch = item.match(/title:\s*['"]([^'"]+)['"]/);
              result.title = titleMatch ? titleMatch[1] : '';
              const linkMatch = item.match(/link:\s*['"]([^'"]+)['"]/);
              result.link = linkMatch ? linkMatch[1] : '';
              return result;
            }).filter(item => item.title && item.link);
          }

          const friendLinks = parseFriendLinks(content);
          
          if (!friendLinks || friendLinks.length === 0) {
            console.log('æœªæ‰¾åˆ°å‹é“¾æ•°æ®');
            process.exit(1);
          }

          const lastItem = friendLinks[friendLinks.length - 1];

          const verifyFileName = `github-pr-verify-${prNumber}.txt`;
          const expectedContent = `verify-pr-${prNumber}`;
          const verifyUrl = `${lastItem.link.replace(/\/$/, '')}/${verifyFileName}`;

          console.log('Verifying:', verifyUrl);

          // æ£€æŸ¥éªŒè¯æ–‡ä»¶
          async function checkVerification() {
            return new Promise((resolve) => {
              const client = verifyUrl.startsWith('https') ? https : http;
              const req = client.get(verifyUrl, { timeout: 10000 }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                  const verified = data.trim() === expectedContent;
                  console.log('Verification result:', verified);
                  console.log('Expected:', expectedContent);
                  console.log('Got:', data.trim());
                  resolve(verified);
                });
              });
              req.on('error', (e) => {
                console.log('Error:', e.message);
                resolve(false);
              });
              req.on('timeout', () => {
                req.destroy();
                resolve(false);
              });
            });
          }

          checkVerification().then(verified => {
            const fs2 = require('fs');
            fs2.appendFileSync(process.env.GITHUB_OUTPUT, `verified=${verified}\n`);
            fs2.appendFileSync(process.env.GITHUB_OUTPUT, `link=${lastItem.link}\n`);
            process.exit(0);
          });
          EOF

      - name: Merge PR if verified
        if: steps.pr-info.outputs.has_friend_link_label == 'true' && steps.pr-info.outputs.has_verify_label == 'true' && steps.verify.outputs.verified == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            // æ›´æ–°æ ‡ç­¾
            await github.rest.issues.removeLabel({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'æ‰€æœ‰æƒéªŒè¯è¿›è¡Œä¸­'
            }).catch(() => {});

            await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['æ‰€æœ‰æƒéªŒè¯é€šè¿‡']
            });

            // è¯„è®º
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: 'âœ… æ‰€æœ‰æƒéªŒè¯é€šè¿‡ï¼æ­£åœ¨è‡ªåŠ¨åˆå¹¶PR...'
            });

            // åˆå¹¶PR
            await github.rest.pulls.merge({
              pull_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              merge_method: 'squash'
            });

      - name: Comment if verification failed
        if: steps.pr-info.outputs.has_friend_link_label == 'true' && steps.pr-info.outputs.has_verify_label == 'true' && steps.verify.outputs.verified == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const link = '${{ steps.verify.outputs.link }}';
            const prNumber = context.issue.number;
            const verifyFileName = `github-pr-verify-${prNumber}.txt`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `âŒ æ‰€æœ‰æƒéªŒè¯å¤±è´¥ï¼

è¯·ç¡®ä¿ï¼š
1. åœ¨ç½‘ç«™ \`${link}\` çš„æ ¹ç›®å½•æ”¾ç½®äº†æ–‡ä»¶ \`${verifyFileName}\`
2. æ–‡ä»¶å†…å®¹ä¸º \`verify-pr-${prNumber}\`
3. æ–‡ä»¶å¯ä»¥é€šè¿‡ \`${link}/${verifyFileName}\` è®¿é—®

ç¡®è®¤æ— è¯¯åï¼Œè¯·å†æ¬¡å›å¤ **"å‡†å¤‡å®Œæ¯•"** è¿›è¡ŒéªŒè¯ã€‚`
            });
